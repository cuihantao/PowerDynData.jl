var documenterSearchIndex = {"docs":
[{"location":"#PowerDynData","page":"Home","title":"PowerDynData","text":"Documentation for PowerDynData.\n\n","category":"section"},{"location":"#PowerDynData.DEBUG_LEVEL","page":"Home","title":"PowerDynData.DEBUG_LEVEL","text":"DEBUG_LEVEL\n\nGlobal debug level reference. Set to 0 to disable all debug output. Levels:\n\n0: No debug output\n1: Basic parsing progress\n2: Detailed field parsing\n3: Verbose byte-level operations\n\n\n\n\n\n","category":"constant"},{"location":"#PowerDynData.DynamicData","page":"Home","title":"PowerDynData.DynamicData","text":"struct DynamicData\n\nTop-level container for all dynamic data from a DYR file.\n\nFields\n\nmodels::Dict{String, DynamicRecords}: Dictionary mapping model names to their records\nmetadata_registry::Union{Nothing, MetadataRegistry}: Metadata registry (if loaded)\nsource_file::String: Source file path\nvalidation_issues::Vector{ValidationIssue}: Validation issues encountered during parsing\n\nExamples\n\ndd = parse_dyr(\"case.dyr\", metadata_dir=\"metadata\")\n\n# Access models\ngenrou = dd[\"GENROU\"]\ntgov1 = dd[\"TGOV1\"]\n\n# Get available models\nkeys(dd)\n\n# Check validation issues\nif !isempty(dd.validation_issues)\n    for issue in dd.validation_issues\n        println(\"$(issue.model_name)[$(issue.record_index)].$(issue.field_name): $(issue.message)\")\n    end\nend\n\n# Convert to DataFrame\nusing DataFrames\ndf = DataFrame(dd[\"GENROU\"])\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.DynamicRecords","page":"Home","title":"PowerDynData.DynamicRecords","text":"abstract type DynamicRecords\n\nAbstract base type for all dynamic record collections.\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.FieldMetadata","page":"Home","title":"PowerDynData.FieldMetadata","text":"struct FieldMetadata\n\nMetadata for a single field in a model.\n\nFields\n\nname::Symbol: Field name\nposition::Int64: Position in DYR record (1-indexed)\ntype::Type: Julia type for this field\ndescription::String: Human-readable description\nunit::String: Physical unit (e.g., 'seconds', 'MW', 'dimensionless')\nrequired::Bool: Whether this field is required\ndefault::Any: Default value if not provided\nrange::Union{Nothing, Tuple{Float64, Float64}}: Valid range for numeric fields\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.FieldValue","page":"Home","title":"PowerDynData.FieldValue","text":"FieldValue\n\nRepresents a field value extraction result.\n\nfound: Whether the field was found in the source\nraw_value: The raw value (only valid if found=true)\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.IndexedDynamicRecords","page":"Home","title":"PowerDynData.IndexedDynamicRecords","text":"struct IndexedDynamicRecords <: DynamicRecords\n\nDynamic records without metadata (fallback mode with indexed fields).\n\nFields\n\nmodel_name::String: Model name\nfields::Vector{Vector{Any}}: Raw field data as vector of vectors\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.MetadataRegistry","page":"Home","title":"PowerDynData.MetadataRegistry","text":"struct MetadataRegistry\n\nRegistry of all loaded model metadata.\n\nFields\n\nmodels::Dict{String, PowerDynData.ModelMetadata}: Dictionary mapping model name to metadata\ncategories::Dict{String, Vector{String}}: Dictionary mapping category to list of model names\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.ModelMetadata","page":"Home","title":"PowerDynData.ModelMetadata","text":"struct ModelMetadata\n\nComplete metadata for a PSS/E dynamic model.\n\nFields\n\nname::String: Model name (e.g., 'GENROU')\ndescription::String: Description of the model\ncategory::String: Category (e.g., 'generator', 'exciter', 'governor')\nmodel_name_field::Int64: Position of model name field in DYR record\nmulti_line::Bool: Whether record spans multiple lines\nline_count::Union{Nothing, Int64}: Number of lines (if multi_line)\nterminator::String: Record terminator character\nflexible_fields::Bool: Allow variable number of fields\nfields::Vector{PowerDynData.FieldMetadata}: Field metadata for all fields in order\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.NamedDynamicRecords","page":"Home","title":"PowerDynData.NamedDynamicRecords","text":"struct NamedDynamicRecords{T} <: DynamicRecords\n\nDynamic records with metadata-driven named fields.\n\nFields\n\nmodel_name::String: Model name (e.g., 'GENROU', 'ESST3A')\ncategory::String: Model category (e.g., 'generator', 'exciter')\ndata::Any: StructArray containing the actual data with named columns\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.ParsedRecord","page":"Home","title":"PowerDynData.ParsedRecord","text":"ParsedRecord\n\nIntermediate structure for a parsed DYR record.\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.ValidationIssue","page":"Home","title":"PowerDynData.ValidationIssue","text":"struct ValidationIssue\n\nRepresents a validation issue encountered during parsing.\n\nFields\n\nmodel_name::String: Model name where issue occurred\nrecord_index::Int64: Record index (1-based) within the model\nfield_name::Symbol: Field name where issue occurred\nissue_type::Symbol: Type of issue (:outofrange, :parse_error, etc.)\nmessage::String: Human-readable message\nvalue::Any: The actual value that caused the issue\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.convert_toml_value-Tuple{Type, Any}","page":"Home","title":"PowerDynData.convert_toml_value","text":"convert_toml_value(expected_type::Type, value::Any) -> Any\n\nConvert a TOML-parsed value to the expected type.\n\nTOML already preserves types (Int, Float64, String, Bool), but we need to handle:\n\nType mismatches (user put string where float expected)\nAutomatic Int → Float64 promotion\n\nThis function is self-contained and does not depend on DYR-specific parsing functions.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_indexed_records-Tuple{String, Vector{PowerDynData.ParsedRecord}}","page":"Home","title":"PowerDynData.create_indexed_records","text":"create_indexed_records(model_name::String, records::Vector{ParsedRecord}) -> IndexedDynamicRecords\n\nCreate IndexedDynamicRecords (fallback when no metadata available).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_indexed_records_from_toml-Tuple{String, Vector}","page":"Home","title":"PowerDynData.create_indexed_records_from_toml","text":"create_indexed_records_from_toml(model_name, records) -> IndexedDynamicRecords\n\nCreate IndexedDynamicRecords from TOML (fallback when no metadata available).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_named_records-Tuple{String, PowerDynData.ModelMetadata, Vector{PowerDynData.ParsedRecord}, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.create_named_records","text":"create_named_records(model_name::String, metadata::ModelMetadata, records::Vector{ParsedRecord}, validation_issues::Vector{ValidationIssue}) -> NamedDynamicRecords\n\nCreate NamedDynamicRecords using metadata schema.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_named_records_from_toml-Tuple{String, PowerDynData.ModelMetadata, Vector, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.create_named_records_from_toml","text":"create_named_records_from_toml(model_name, metadata, records, validation_issues) -> NamedDynamicRecords\n\nCreate NamedDynamicRecords from TOML parsed data using metadata schema.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_named_records_generic-Tuple{String, PowerDynData.ModelMetadata, Vector, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.create_named_records_generic","text":"create_named_records_generic(\n    model_name, metadata, records, validation_issues;\n    get_field_value, convert_value, on_unknown_field=nothing\n) -> NamedDynamicRecords\n\nGeneric function to create NamedDynamicRecords from any source format.\n\nArguments\n\nmodel_name: Name of the model (e.g., \"GENROU\")\nmetadata: ModelMetadata with field definitions\nrecords: Vector of source records (format-specific)\nvalidation_issues: Vector to collect validation issues\n\nKeyword Arguments\n\nget_field_value(record, field_meta) -> FieldValue: Extract field value from record\nconvert_value(field_meta, raw_value) -> value: Convert raw value to expected type\non_unknown_field(record, record_idx) -> nothing: Optional callback for unknown field detection\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_typed_vectors-Tuple{Dict{Symbol, Vector{Any}}, Vector{PowerDynData.FieldMetadata}}","page":"Home","title":"PowerDynData.create_typed_vectors","text":"create_typed_vectors(field_data, field_metas) -> Dict{Symbol, Vector}\n\nConvert heterogeneous field data vectors to properly typed vectors.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.detect_model_name-Tuple{AbstractString}","page":"Home","title":"PowerDynData.detect_model_name","text":"detect_model_name(line::AbstractString) -> Union{String, Nothing}\n\nDetect model name in a DYR line by finding quoted string.\n\nModel names are enclosed in single quotes.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.dyr_to_toml-Tuple{Union{IO, String}, Union{IO, String}}","page":"Home","title":"PowerDynData.dyr_to_toml","text":"dyr_to_toml(dyr_source, toml_dest; metadata_dir=...) -> String\n\nConvert a DYR file to TOML format.\n\nArguments\n\ndyr_source: Path to DYR file or IO object\ntoml_dest: Path to output TOML file or IO object\nmetadata_dir: Path to metadata directory (defaults to bundled metadata)\n\nReturns\n\nPath to the created TOML file (if file path given) or the destination IO\n\nExamples\n\n# Convert file\ndyr_to_toml(\"case.dyr\", \"case.toml\")\n\n# Convert to IO\nio = IOBuffer()\ndyr_to_toml(\"case.dyr\", io)\ntoml_string = String(take!(io))\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.get_model_metadata-Tuple{MetadataRegistry, String}","page":"Home","title":"PowerDynData.get_model_metadata","text":"get_model_metadata(registry::MetadataRegistry, model_name::String) -> Union{ModelMetadata, Nothing}\n\nRetrieve metadata for a specific model from the registry.\n\nReturns nothing if model is not found.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.group_records_by_model-Tuple{Vector{PowerDynData.ParsedRecord}, Union{Nothing, MetadataRegistry}, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.group_records_by_model","text":"group_records_by_model(records::Vector{ParsedRecord}, registry::Union{MetadataRegistry, Nothing}, validation_issues::Vector{ValidationIssue}) -> Dict{String, DynamicRecords}\n\nGroup parsed records by model name and create DynamicRecords for each model type.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.handle_conversion_error!-Tuple{Dict{Symbol, Vector{Any}}, Vector{ValidationIssue}, String, Int64, PowerDynData.FieldMetadata, Any, Any}","page":"Home","title":"PowerDynData.handle_conversion_error!","text":"handle_conversion_error!(field_data, validation_issues, model_name, record_idx, field_meta, raw_value, error)\n\nHandle a value conversion error by recording the issue and using the default value.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.handle_missing_field!-Tuple{Dict{Symbol, Vector{Any}}, Vector{ValidationIssue}, String, Int64, PowerDynData.FieldMetadata}","page":"Home","title":"PowerDynData.handle_missing_field!","text":"handle_missing_field!(field_data, validation_issues, model_name, record_idx, field_meta)\n\nHandle a missing field by recording validation issue (if required) and using default.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.indexed_records_to_dicts-Tuple{IndexedDynamicRecords}","page":"Home","title":"PowerDynData.indexed_records_to_dicts","text":"indexed_records_to_dicts(records::IndexedDynamicRecords) -> Vector{Dict{String, Any}}\n\nConvert IndexedDynamicRecords to a vector of dictionaries for TOML output. Uses indexed field names (field1, field2, etc.) since no metadata is available.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.load_metadata_registry-Tuple{String}","page":"Home","title":"PowerDynData.load_metadata_registry","text":"load_metadata_registry(metadata_dir::String) -> MetadataRegistry\n\nLoad all YAML metadata files from a directory tree.\n\nRecursively scans metadata_dir for .yaml/.yml files and parses them into ModelMetadata objects. Organizes models by category.\n\nArguments\n\nmetadata_dir: Path to directory containing YAML metadata files\n\nReturns\n\nMetadataRegistry: Registry containing all loaded metadata\n\nExamples\n\nregistry = load_metadata_registry(\"metadata\")\ngenrou_meta = get_model_metadata(registry, \"GENROU\")\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.named_records_to_dicts-Tuple{NamedDynamicRecords}","page":"Home","title":"PowerDynData.named_records_to_dicts","text":"named_records_to_dicts(records::NamedDynamicRecords) -> Vector{Dict{String, Any}}\n\nConvert NamedDynamicRecords to a vector of dictionaries for TOML output.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_all_records-Tuple{String, Union{Nothing, MetadataRegistry}}","page":"Home","title":"PowerDynData.parse_all_records","text":"parse_all_records(content::String, registry::Union{MetadataRegistry, Nothing}) -> Vector{ParsedRecord}\n\nParse all records from DYR file content.\n\nReturns a vector of ParsedRecord structs containing model name and field values.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_dyr-Tuple{Union{IO, String}}","page":"Home","title":"PowerDynData.parse_dyr","text":"parse_dyr(source; metadata_dir=pkgdir(PowerDynData, \"metadata\")) -> DynamicData\n\nParse a PSS/E DYR file into structured data.\n\nArguments\n\nsource: Path to DYR file or IO object\nmetadata_dir: Path to metadata directory. Defaults to bundled metadata at pkgdir(PowerDynData, \"metadata\"). Set to nothing to disable metadata and use indexed fields only. Can be set to a custom path for user-defined metadata.\n\nReturns\n\nDynamicData: Container with all parsed models\n\nExamples\n\n# With bundled metadata (default - recommended)\ndd = parse_dyr(\"case.dyr\")\n\n# Access models with named fields\nusing DataFrames\ngenrou_df = DataFrame(dd[\"GENROU\"])\n\n# Without metadata (indexed fallback)\ndd = parse_dyr(\"case.dyr\", metadata_dir=nothing)\n\n# With custom metadata directory\ndd = parse_dyr(\"case.dyr\", metadata_dir=\"path/to/custom/metadata\")\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_field-Tuple{Type{Int64}, AbstractString}","page":"Home","title":"PowerDynData.parse_field","text":"parse_field(::Type{T}, s::AbstractString) -> T\n\nParse a single field value as type T.\n\nHandles scientific notation (e.g., 0.60000E-01).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_metadata_file-Tuple{String}","page":"Home","title":"PowerDynData.parse_metadata_file","text":"parse_metadata_file(filepath::String) -> ModelMetadata\n\nParse a single YAML metadata file into ModelMetadata.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_range-Tuple{Nothing}","page":"Home","title":"PowerDynData.parse_range","text":"parse_range(r) -> Union{Nothing, Tuple{Float64, Float64}}\n\nParse range from YAML (can be array or nothing).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_single_record-Tuple{String, Union{Nothing, MetadataRegistry}}","page":"Home","title":"PowerDynData.parse_single_record","text":"parse_single_record(record_str::String, registry::Union{MetadataRegistry, Nothing}) -> Union{ParsedRecord, Nothing}\n\nParse a single complete record (possibly spanning multiple lines).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_toml-Tuple{Union{IO, String}}","page":"Home","title":"PowerDynData.parse_toml","text":"parse_toml(source; metadata_dir=pkgdir(PowerDynData, \"metadata\")) -> DynamicData\n\nParse a TOML file containing dynamic model data into structured data.\n\nArguments\n\nsource: Path to TOML file or IO object\nmetadata_dir: Path to metadata directory. Defaults to bundled metadata at pkgdir(PowerDynData, \"metadata\"). Set to nothing to disable metadata and use indexed fields only.\n\nReturns\n\nDynamicData: Container with all parsed models (same structure as parse_dyr)\n\nTOML Format Specification\n\nThe TOML format uses arrays of tables to represent multiple instances of each model type. Each table entry corresponds to one device record.\n\nStructure\n\nModel arrays: Use [[MODEL_NAME]] syntax (double brackets) for each device instance\nField names: Must match metadata YAML field names exactly (case-sensitive)\nComments: Use # for comments (preserved in TOML, unlike DYR format)\nTypes: TOML preserves native types (Int, Float64, String, Bool)\n\nField Types\n\nInteger fields: BUS = 1 (no quotes, no decimal)\nFloat fields: H = 4.0 or H = 4 (integers auto-promoted to Float64)\nString fields: ID = \"1\" (double quotes required)\nBoolean fields: enabled = true or enabled = false\n\nExample File\n\n# IEEE 14-bus dynamic data\n# Comments are supported and encouraged\n\n# Generator models - 5 GENROU units\n[[GENROU]]\nBUS = 1\nID = \"1\"\nTd10 = 6.5      # Direct axis transient time constant\nTd20 = 0.06     # Direct axis subtransient time constant\nTq10 = 0.2      # Quadrature axis transient time constant\nTq20 = 0.05     # Quadrature axis subtransient time constant\nH = 4.0         # Inertia constant (MW·s/MVA)\nD = 0.0         # Damping coefficient\nXd = 1.8        # Direct axis synchronous reactance\nXq = 1.75       # Quadrature axis synchronous reactance\nXd1 = 0.6       # Direct axis transient reactance\nXq1 = 0.8       # Quadrature axis transient reactance\nXd2 = 0.23      # Direct axis subtransient reactance\nXl = 0.15       # Leakage reactance\nS10 = 0.09      # Saturation factor at 1.0 pu\nS12 = 0.38      # Saturation factor at 1.2 pu\n\n[[GENROU]]\nBUS = 2\nID = \"1\"\n# ... (remaining fields)\n\n# Governor models - TGOV1 steam turbine governors\n[[TGOV1]]\nBUS = 1\nID = \"1\"\nR = 0.05        # Permanent droop (pu)\nDt = 0.05       # Turbine damping coefficient (pu)\nVmax = 1.05     # Maximum valve position (pu)\nVmin = 0.3      # Minimum valve position (pu)\nT1 = 1.0        # Governor time constant (s)\nT2 = 2.1        # Turbine time constant (s)\nT3 = 0.0        # Valve positioner time constant (s)\n\nValidation\n\nUnknown fields generate warnings but parsing continues\nOut-of-range values are recorded as validation issues (accessible via dd.validation_issues)\nMissing required fields are recorded as validation issues\nType mismatches attempt conversion; failures recorded as parse errors\n\nComparison with DYR Format\n\nFeature DYR TOML\nField identification By position By name\nComments Limited (@!, //) Full support (#)\nReadability Requires metadata reference Self-documenting\nVersion control Difficult diffs Clean diffs\nType safety All text Native types\n\nExamples\n\n# Parse TOML file\ndd = parse_toml(\"case.toml\")\n\n# Access models (same API as DYR)\ngenrou = dd[\"GENROU\"]\ndf = DataFrame(genrou)\n\n# Check validation issues\nif !isempty(dd.validation_issues)\n    for issue in dd.validation_issues\n        @warn \"Validation: $(issue.model_name).$(issue.field_name): $(issue.message)\"\n    end\nend\n\n# Without metadata (indexed fallback)\ndd = parse_toml(\"case.toml\", metadata_dir=nothing)\n\nSee also: parse_dyr, dyr_to_toml\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.skip_whitespace_and_comments-Tuple{Vector{SubString{String}}, Int64}","page":"Home","title":"PowerDynData.skip_whitespace_and_comments","text":"skip_whitespace_and_comments(lines::Vector{SubString{String}}, i::Int) -> Int\n\nSkip whitespace and comment lines, returning index of next non-comment line.\n\nComment markers: @!, //\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.skip_whitespace_and_comments_vec-Tuple{Vector{SubString{String}}, Int64}","page":"Home","title":"PowerDynData.skip_whitespace_and_comments_vec","text":"skip_whitespace_and_comments_vec(lines::Vector{SubString{String}}, i::Int) -> Int\n\nSkip whitespace and comment lines.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.split_fields-Tuple{String}","page":"Home","title":"PowerDynData.split_fields","text":"split_fields(s::String) -> Vector{String}\n\nSplit a string into fields, respecting quoted strings.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.string_to_type-Tuple{String}","page":"Home","title":"PowerDynData.string_to_type","text":"string_to_type(s::String) -> Type\n\nConvert type string from YAML to Julia Type.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.validate_field_range!-Tuple{Vector{ValidationIssue}, String, Int64, PowerDynData.FieldMetadata, Any}","page":"Home","title":"PowerDynData.validate_field_range!","text":"validate_field_range!(validation_issues, model_name, record_idx, field_meta, value)\n\nCheck if value is within the valid range and record validation issue if not.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.validate_range-Tuple{Number, Tuple{Float64, Float64}, Symbol}","page":"Home","title":"PowerDynData.validate_range","text":"validate_range(value::Number, range::Tuple{Float64, Float64}, field_name::Symbol)\n\nValidate that a numeric value falls within the specified range.\n\nThrows an error if validation fails.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.@pdebug-Tuple{Any, Any}","page":"Home","title":"PowerDynData.@pdebug","text":"@pdebug level msg\n\nPrint debug message if DEBUG_LEVEL[] >= level.\n\nNamed @pdebug to avoid conflicts with Julia's built-in @debug macro.\n\nExamples\n\nPowerDynData.DEBUG_LEVEL[] = 1\n@pdebug 1 \"Parsing model: GENROU\"  # Prints\n@pdebug 2 \"Field value: $(val)\"    # Does not print\n\n\n\n\n\n","category":"macro"}]
}
