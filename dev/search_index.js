var documenterSearchIndex = {"docs":
[{"location":"#PowerDynData","page":"Home","title":"PowerDynData","text":"Documentation for PowerDynData.\n\n","category":"section"},{"location":"#PowerDynData.DEBUG_LEVEL","page":"Home","title":"PowerDynData.DEBUG_LEVEL","text":"DEBUG_LEVEL\n\nGlobal debug level reference. Set to 0 to disable all debug output. Levels:\n\n0: No debug output\n1: Basic parsing progress\n2: Detailed field parsing\n3: Verbose byte-level operations\n\n\n\n\n\n","category":"constant"},{"location":"#PowerDynData.MAX_METADATA_FILE_SIZE","page":"Home","title":"PowerDynData.MAX_METADATA_FILE_SIZE","text":"Maximum allowed size for metadata files (in bytes). Metadata files should be small (<1MB); larger files likely indicate an error.\n\n\n\n\n\n","category":"constant"},{"location":"#PowerDynData.MAX_TOML_FILE_SIZE","page":"Home","title":"PowerDynData.MAX_TOML_FILE_SIZE","text":"Maximum allowed size for TOML data files (in bytes). Large power system models may have substantial data files, but >100MB likely indicates an error.\n\n\n\n\n\n","category":"constant"},{"location":"#PowerDynData.DynamicData","page":"Home","title":"PowerDynData.DynamicData","text":"struct DynamicData\n\nTop-level container for all dynamic data from a DYR file.\n\nFields\n\nmodels::Dict{String, DynamicRecords}: Dictionary mapping model names to their records\nmetadata_registry::Union{Nothing, MetadataRegistry}: Metadata registry (if loaded)\nsource_file::String: Source file path\nvalidation_issues::Vector{ValidationIssue}: Validation issues encountered during parsing\n\nExamples\n\ndd = parse_dyr(\"case.dyr\", metadata_dir=\"metadata\")\n\n# Access models\ngenrou = dd[\"GENROU\"]\ntgov1 = dd[\"TGOV1\"]\n\n# Get available models\nkeys(dd)\n\n# Check validation issues\nif !isempty(dd.validation_issues)\n    for issue in dd.validation_issues\n        println(\"$(issue.model_name)[$(issue.record_index)].$(issue.field_name): $(issue.message)\")\n    end\nend\n\n# Convert to DataFrame\nusing DataFrames\ndf = DataFrame(dd[\"GENROU\"])\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.DynamicRecords","page":"Home","title":"PowerDynData.DynamicRecords","text":"abstract type DynamicRecords\n\nAbstract base type for all dynamic record collections.\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.FieldMetadata","page":"Home","title":"PowerDynData.FieldMetadata","text":"struct FieldMetadata\n\nMetadata for a single field in a model.\n\nFields\n\nname::Symbol: Field name\nposition::Int64: Position in DYR record (1-indexed)\ntype::Type: Julia type for this field\ndescription::String: Human-readable description\nunit::String: Physical unit (e.g., 'seconds', 'MW', 'dimensionless')\nrequired::Bool: Whether this field is required\ndefault::Any: Default value if not provided\nrange::Union{Nothing, Tuple{Float64, Float64}}: Valid range for numeric fields\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.FieldValue","page":"Home","title":"PowerDynData.FieldValue","text":"FieldValue\n\nRepresents a field value extraction result.\n\nfound: Whether the field was found in the source\nraw_value: The raw value (only valid if found=true)\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.IndexedDynamicRecords","page":"Home","title":"PowerDynData.IndexedDynamicRecords","text":"struct IndexedDynamicRecords <: DynamicRecords\n\nDynamic records without metadata (fallback mode with indexed fields).\n\nFields\n\nmodel_name::String: Model name\nfields::Vector{Vector{Any}}: Raw field data as vector of vectors\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.MetadataRegistry","page":"Home","title":"PowerDynData.MetadataRegistry","text":"struct MetadataRegistry\n\nRegistry of all loaded model metadata.\n\nFields\n\nmodels::Dict{String, PowerDynData.ModelMetadata}: Dictionary mapping model name to metadata\ncategories::Dict{String, Vector{String}}: Dictionary mapping category to list of model names\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.ModelMetadata","page":"Home","title":"PowerDynData.ModelMetadata","text":"struct ModelMetadata\n\nComplete metadata for a PSS/E dynamic model.\n\nFields\n\nname::String: Model name (e.g., 'GENROU')\ndescription::String: Description of the model\ncategory::String: Category (e.g., 'generator', 'exciter', 'governor')\nmodel_name_field::Int64: Position of model name field in DYR record\nmulti_line::Bool: Whether record spans multiple lines\nline_count::Union{Nothing, Int64}: Number of lines (if multi_line)\nterminator::String: Record terminator character\nflexible_fields::Bool: Allow variable number of fields\nfields::Vector{PowerDynData.FieldMetadata}: Field metadata for all fields in order\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.NamedDynamicRecords","page":"Home","title":"PowerDynData.NamedDynamicRecords","text":"struct NamedDynamicRecords{T} <: DynamicRecords\n\nDynamic records with metadata-driven named fields.\n\nFields\n\nmodel_name::String: Model name (e.g., 'GENROU', 'ESST3A')\ncategory::String: Model category (e.g., 'generator', 'exciter')\ndata::Any: StructArray containing the actual data with named columns\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.ParsedRecord","page":"Home","title":"PowerDynData.ParsedRecord","text":"ParsedRecord\n\nIntermediate structure for a parsed DYR record.\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData.ValidationIssue","page":"Home","title":"PowerDynData.ValidationIssue","text":"struct ValidationIssue\n\nRepresents a validation issue encountered during parsing.\n\nFields\n\nmodel_name::String: Model name where issue occurred\nrecord_index::Int64: Record index (1-based) within the model\nfield_name::Symbol: Field name where issue occurred\nissue_type::Symbol: Type of issue (:outofrange, :parse_error, etc.)\nmessage::String: Human-readable message\nvalue::Any: The actual value that caused the issue\n\n\n\n\n\n","category":"type"},{"location":"#PowerDynData._parse_metadata_dict-Tuple{AbstractDict}","page":"Home","title":"PowerDynData._parse_metadata_dict","text":"_parse_metadata_dict(data::Dict) -> ModelMetadata\n\nInternal function to parse metadata from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.convert_toml_value-Tuple{Type, Any}","page":"Home","title":"PowerDynData.convert_toml_value","text":"convert_toml_value(expected_type::Type, value::Any) -> Any\n\nConvert a TOML-parsed value to the expected type.\n\nTOML already preserves types (Int, Float64, String, Bool), but we need to handle:\n\nType mismatches (user put string where float expected)\nAutomatic Int → Float64 promotion\n\nThis function is self-contained and does not depend on DYR-specific parsing functions.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_indexed_records-Tuple{String, Vector{PowerDynData.ParsedRecord}}","page":"Home","title":"PowerDynData.create_indexed_records","text":"create_indexed_records(model_name::String, records::Vector{ParsedRecord}) -> IndexedDynamicRecords\n\nCreate IndexedDynamicRecords (fallback when no metadata available).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_indexed_records_from_toml-Tuple{String, Vector}","page":"Home","title":"PowerDynData.create_indexed_records_from_toml","text":"create_indexed_records_from_toml(model_name, records) -> IndexedDynamicRecords\n\nCreate IndexedDynamicRecords from TOML (fallback when no metadata available).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_named_records-Tuple{String, PowerDynData.ModelMetadata, Vector{PowerDynData.ParsedRecord}, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.create_named_records","text":"create_named_records(model_name::String, metadata::ModelMetadata, records::Vector{ParsedRecord}, validation_issues::Vector{ValidationIssue}) -> NamedDynamicRecords\n\nCreate NamedDynamicRecords using metadata schema.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_named_records_from_toml-Tuple{String, PowerDynData.ModelMetadata, Vector, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.create_named_records_from_toml","text":"create_named_records_from_toml(model_name, metadata, records, validation_issues) -> NamedDynamicRecords\n\nCreate NamedDynamicRecords from TOML parsed data using metadata schema.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_named_records_generic-Tuple{String, PowerDynData.ModelMetadata, Vector, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.create_named_records_generic","text":"create_named_records_generic(\n    model_name, metadata, records, validation_issues;\n    get_field_value, convert_value, on_unknown_field=nothing\n) -> NamedDynamicRecords\n\nGeneric function to create NamedDynamicRecords from any source format.\n\nArguments\n\nmodel_name: Name of the model (e.g., \"GENROU\")\nmetadata: ModelMetadata with field definitions\nrecords: Vector of source records (format-specific)\nvalidation_issues: Vector to collect validation issues\n\nKeyword Arguments\n\nget_field_value(record, field_meta) -> FieldValue: Extract field value from record\nconvert_value(field_meta, raw_value) -> value: Convert raw value to expected type\non_unknown_field(record, record_idx) -> nothing: Optional callback for unknown field detection\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.create_typed_vectors-Tuple{Dict{Symbol, Vector{Any}}, Vector{PowerDynData.FieldMetadata}}","page":"Home","title":"PowerDynData.create_typed_vectors","text":"create_typed_vectors(field_data, field_metas) -> Dict{Symbol, Vector}\n\nConvert heterogeneous field data vectors to properly typed vectors.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.detect_model_name-Tuple{AbstractString}","page":"Home","title":"PowerDynData.detect_model_name","text":"detect_model_name(line::AbstractString) -> Union{String, Nothing}\n\nDetect model name in a DYR line by finding quoted string.\n\nModel names are enclosed in single quotes.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.dyr_to_toml-Tuple{Union{IO, String}, Union{IO, String}}","page":"Home","title":"PowerDynData.dyr_to_toml","text":"dyr_to_toml(dyr_source, toml_dest; metadata_dir=...) -> String\n\nConvert a DYR file to TOML format.\n\nArguments\n\ndyr_source: Path to DYR file or IO object\ntoml_dest: Path to output TOML file or IO object\nmetadata_dir: Path to metadata directory (defaults to bundled metadata)\n\nReturns\n\nPath to the created TOML file (if file path given) or the destination IO\n\nExamples\n\n# Convert file\ndyr_to_toml(\"case.dyr\", \"case.toml\")\n\n# Convert to IO\nio = IOBuffer()\ndyr_to_toml(\"case.dyr\", io)\ntoml_string = String(take!(io))\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.get_model_metadata-Tuple{MetadataRegistry, String}","page":"Home","title":"PowerDynData.get_model_metadata","text":"get_model_metadata(registry::MetadataRegistry, model_name::String) -> Union{ModelMetadata, Nothing}\n\nRetrieve metadata for a specific model from the registry.\n\nReturns nothing if model is not found.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.group_records_by_model-Tuple{Vector{PowerDynData.ParsedRecord}, Union{Nothing, MetadataRegistry}, Vector{ValidationIssue}}","page":"Home","title":"PowerDynData.group_records_by_model","text":"group_records_by_model(records::Vector{ParsedRecord}, registry::Union{MetadataRegistry, Nothing}, validation_issues::Vector{ValidationIssue}) -> Dict{String, DynamicRecords}\n\nGroup parsed records by model name and create DynamicRecords for each model type.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.handle_conversion_error!-Tuple{Dict{Symbol, Vector{Any}}, Vector{ValidationIssue}, String, Int64, PowerDynData.FieldMetadata, Any, Any}","page":"Home","title":"PowerDynData.handle_conversion_error!","text":"handle_conversion_error!(field_data, validation_issues, model_name, record_idx, field_meta, raw_value, error)\n\nHandle a value conversion error by recording the issue and using the default value.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.handle_missing_field!-Tuple{Dict{Symbol, Vector{Any}}, Vector{ValidationIssue}, String, Int64, PowerDynData.FieldMetadata}","page":"Home","title":"PowerDynData.handle_missing_field!","text":"handle_missing_field!(field_data, validation_issues, model_name, record_idx, field_meta)\n\nHandle a missing field by recording validation issue (if required) and using default.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.indexed_records_to_dicts-Tuple{IndexedDynamicRecords}","page":"Home","title":"PowerDynData.indexed_records_to_dicts","text":"indexed_records_to_dicts(records::IndexedDynamicRecords) -> Vector{Dict{String, Any}}\n\nConvert IndexedDynamicRecords to a vector of dictionaries for TOML output. Uses indexed field names (field1, field2, etc.) since no metadata is available.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.load_metadata_registry-Tuple{String}","page":"Home","title":"PowerDynData.load_metadata_registry","text":"load_metadata_registry(metadata_dir::String) -> MetadataRegistry\n\nLoad all metadata files from a directory tree into a structured registry.\n\nRecursively scans metadata_dir for YAML metadata files (.yaml or .yml) and parses them into ModelMetadata objects. Models are automatically organized by the category field in each YAML file.\n\nArguments\n\nmetadata_dir: Path to directory containing metadata files. Can include subdirectories (e.g., metadata/generators/, metadata/exciters/).\n\nReturns\n\nMetadataRegistry: Registry containing all successfully loaded metadata\n\nDirectory Structure\n\nThe metadata directory can be organized hierarchically. All .yaml and .yml files are discovered recursively:\n\nmetadata/\n├── generators/\n│   ├── GENROU.yaml\n│   └── GENCLS.yaml\n├── exciters/\n│   └── ESST3A.yaml\n└── governors/\n    └── TGOV1.yaml\n\nError Handling\n\nInvalid YAML files: Logged as warnings, parsing continues for other files\nMissing directory: Throws system error (check with isdir first)\nEmpty directory: Returns empty registry (0 models, 0 categories)\nOversized files: Throws error for files exceeding 1024 KB\n\nExamples\n\n# Load bundled metadata (recommended)\nregistry = load_metadata_registry(pkgdir(PowerDynData, \"metadata\"))\nprintln(keys(registry.models))  # => [\"GENROU\", \"GENCLS\", \"TGOV1\", ...]\n\n# Load custom metadata\nregistry = load_metadata_registry(\"/path/to/custom/metadata\")\n\n# Check if directory exists first\nmetadata_dir = \"my_metadata\"\nif isdir(metadata_dir)\n    registry = load_metadata_registry(metadata_dir)\nelse\n    @warn \"Metadata directory not found: $metadata_dir\"\nend\n\nSee also: MetadataRegistry, parse_dyr, parse_toml\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.named_records_to_dicts-Tuple{NamedDynamicRecords}","page":"Home","title":"PowerDynData.named_records_to_dicts","text":"named_records_to_dicts(records::NamedDynamicRecords) -> Vector{Dict{String, Any}}\n\nConvert NamedDynamicRecords to a vector of dictionaries for TOML output.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_all_records-Tuple{String, Union{Nothing, MetadataRegistry}}","page":"Home","title":"PowerDynData.parse_all_records","text":"parse_all_records(content::String, registry::Union{MetadataRegistry, Nothing}) -> Vector{ParsedRecord}\n\nParse all records from DYR file content.\n\nReturns a vector of ParsedRecord structs containing model name and field values.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_dyr-Tuple{Union{IO, String}}","page":"Home","title":"PowerDynData.parse_dyr","text":"parse_dyr(source; metadata_dir=pkgdir(PowerDynData, \"metadata\")) -> DynamicData\n\nParse a PSS/E DYR file into structured data.\n\nArguments\n\nsource: Path to DYR file or IO object\nmetadata_dir: Path to metadata directory. Defaults to bundled YAML metadata at pkgdir(PowerDynData, \"metadata\"). Set to nothing to disable metadata and use indexed fields only. Can be set to a custom path for user-defined metadata.\n\nReturns\n\nDynamicData: Container with all parsed models\n\nExamples\n\n# With bundled metadata (default - recommended)\ndd = parse_dyr(\"case.dyr\")\n\n# Access models with named fields\nusing DataFrames\ngenrou_df = DataFrame(dd[\"GENROU\"])\n\n# Without metadata (indexed fallback)\ndd = parse_dyr(\"case.dyr\", metadata_dir=nothing)\n\n# With custom metadata directory\ndd = parse_dyr(\"case.dyr\", metadata_dir=\"path/to/custom/metadata\")\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_field-Tuple{Type{Int64}, AbstractString}","page":"Home","title":"PowerDynData.parse_field","text":"parse_field(::Type{T}, s::AbstractString) -> T\n\nParse a single field value as type T.\n\nHandles scientific notation (e.g., 0.60000E-01).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_metadata_file-Tuple{String}","page":"Home","title":"PowerDynData.parse_metadata_file","text":"parse_metadata_file(filepath::String) -> ModelMetadata\n\nParse a single YAML metadata file into ModelMetadata.\n\nValidates file size before loading to prevent memory issues with malformed files.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_range-Tuple{Nothing}","page":"Home","title":"PowerDynData.parse_range","text":"parse_range(r) -> Union{Nothing, Tuple{Float64, Float64}}\n\nParse range from metadata (can be array or nothing).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_single_record-Tuple{String, Union{Nothing, MetadataRegistry}}","page":"Home","title":"PowerDynData.parse_single_record","text":"parse_single_record(record_str::String, registry::Union{MetadataRegistry, Nothing}) -> Union{ParsedRecord, Nothing}\n\nParse a single complete record (possibly spanning multiple lines).\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.parse_toml-Tuple{Union{IO, String}}","page":"Home","title":"PowerDynData.parse_toml","text":"parse_toml(source; metadata_dir=pkgdir(PowerDynData, \"metadata\")) -> DynamicData\n\nParse a TOML file containing dynamic model data into structured data.\n\nUses named fields (e.g., BUS = 1, H = 4.0) instead of positional fields. Returns the same DynamicData structure as parse_dyr for interoperability.\n\nArguments\n\nsource: Path to TOML file or IO object\nmetadata_dir: Path to metadata directory. Defaults to bundled YAML metadata at pkgdir(PowerDynData, \"metadata\"). Set to nothing to disable metadata and use indexed fields only.\n\nReturns\n\nDynamicData: Container with all parsed models (same structure as parse_dyr)\n\nTOML Format\n\nUse [[MODEL_NAME]] for each device instance with named fields:\n\n[[GENROU]]\nBUS = 1\nID = \"1\"\nH = 4.0    # Comments supported\n\nField names must match metadata YAML definitions exactly (case-sensitive).\n\nValidation\n\nUnknown fields generate warnings but parsing continues\nOut-of-range values recorded in dd.validation_issues\nType mismatches attempt conversion; failures recorded as parse errors\n\nExamples\n\n# With bundled metadata (default - recommended)\ndd = parse_toml(\"case.toml\")\n\n# Access models with named fields\nusing DataFrames\ngenrou_df = DataFrame(dd[\"GENROU\"])\n\n# Without metadata (indexed fallback)\ndd = parse_toml(\"case.toml\", metadata_dir=nothing)\n\n# With custom metadata directory\ndd = parse_toml(\"case.toml\", metadata_dir=\"path/to/custom/metadata\")\n\nSee also: parse_dyr, dyr_to_toml\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.skip_whitespace_and_comments-Tuple{AbstractVector{<:AbstractString}, Int64}","page":"Home","title":"PowerDynData.skip_whitespace_and_comments","text":"skip_whitespace_and_comments(lines::AbstractVector{<:AbstractString}, i::Int) -> Int\n\nSkip whitespace and comment lines, returning index of next non-comment line.\n\nComment markers: @!, //\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.split_fields-Tuple{String}","page":"Home","title":"PowerDynData.split_fields","text":"split_fields(s::String) -> Vector{String}\n\nSplit a string into fields, respecting quoted strings.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.string_to_type-Tuple{String}","page":"Home","title":"PowerDynData.string_to_type","text":"string_to_type(s::String) -> Type\n\nConvert type string from metadata to Julia Type.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.validate_field_range!-Tuple{Vector{ValidationIssue}, String, Int64, PowerDynData.FieldMetadata, Any}","page":"Home","title":"PowerDynData.validate_field_range!","text":"validate_field_range!(validation_issues, model_name, record_idx, field_meta, value)\n\nCheck if value is within the valid range and record validation issue if not.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.validate_range-Tuple{Number, Tuple{Float64, Float64}, Symbol}","page":"Home","title":"PowerDynData.validate_range","text":"validate_range(value::Number, range::Tuple{Float64, Float64}, field_name::Symbol)\n\nValidate that a numeric value falls within the specified range.\n\nThrows an error if validation fails.\n\n\n\n\n\n","category":"method"},{"location":"#PowerDynData.@pdebug-Tuple{Any, Any}","page":"Home","title":"PowerDynData.@pdebug","text":"@pdebug level msg\n\nPrint debug message if DEBUG_LEVEL[] >= level.\n\nNamed @pdebug to avoid conflicts with Julia's built-in @debug macro.\n\nExamples\n\nPowerDynData.DEBUG_LEVEL[] = 1\n@pdebug 1 \"Parsing model: GENROU\"  # Prints\n@pdebug 2 \"Field value: $(val)\"    # Does not print\n\n\n\n\n\n","category":"macro"}]
}
